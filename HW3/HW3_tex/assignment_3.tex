%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Short Sectioned Assignment
% LaTeX Template
% Version 1.0 (5/5/12)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=a4, fontsize=11pt]{scrartcl} % A4 paper and 11pt font size

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
%\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage{mathtools} %More math! (For dscases)
\usepackage{hyperref} %HTML package
\usepackage{pgfplots} %Makes plots in LaTeX
\usepackage{tikz} %Also tikz?
\usepackage{bm} %makes vectors bold
\usepackage{bbm} %Blackboard bold 1
\usepgfplotslibrary{fillbetween}%Let's me fill between named plots
\usepackage{graphicx} %import pics

\usepackage[noend]{algpseudocode} %Algorithms
\usepackage{algorithm}

\graphicspath{ {Python\_figs/} }
\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{ \normalfont\scshape} % Make all sections the default font and small caps


\renewcommand{\thesubsection}{\alph{subsection}} %Make subsections start with letters

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage{placeins}

\usepackage{listings}
\lstset{language=Python}


%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	Assignment 3}

\author{Benjamin Jakubowski} % Your name

\date{\normalsize\today} % Today's date or a custom date

\begin{document}

\maketitle % Print the title

%----------------------------------------------------------------------------------------
%	PROBLEM 1
%----------------------------------------------------------------------------------------
\section{Illustrating heapsort}

We illustrate the operation of heapsort on the array
\[A = [19, 2, 11, 14, 7, 17, 4, 3, 5, 15]\]
by showing the values in array $A$ after initial heapification and after each call to \texttt{max-heapify}

\begin{center}
\begin{tabular}{| c | c |}
\hline
\textbf{Call} & \textbf{A} \\
\hline
Initial state & A = [19, 2, 11, 14, 7, 17, 4, 3, 5, 15]\\
\hline
After heapification & A =  [19, 15, 17, 14, 7, 11, 4, 3, 5, 2] \\
\hline
After \texttt{max-heapify} call 1 & A = [17, 15, 11, 14, 7, 2, 4, 3, 5, 19] \\
\hline
After \texttt{max-heapify} call 2 & A = [15, 14, 11, 5, 7, 2, 4, 3, 17, 19] \\
\hline
After \texttt{max-heapify} call 3 & A = [14, 7, 11, 5, 3, 2, 4, 15, 17, 19] \\
\hline
After \texttt{max-heapify} call 4 & A = [11, 7, 4, 5, 3, 2, 14, 15, 17, 19] \\
\hline
After \texttt{max-heapify} call 5 & A = [7, 5, 4, 2, 3, 11, 14, 15, 17, 19] \\
\hline
After \texttt{max-heapify} call 6 & A = [5, 3, 4, 2, 7, 11, 14, 15, 17, 19] \\
\hline
After \texttt{max-heapify} call 7 & A = [4, 3, 2, 5, 7, 11, 14, 15, 17, 19] \\
\hline
After \texttt{max-heapify} call 8 & A = [3, 2, 4, 5, 7, 11, 14, 15, 17, 19] \\
\hline
After \texttt{max-heapify} call 9 & A = [2, 3, 4, 5, 7, 11, 14, 15, 17, 19] \\
\hline
\end{tabular}
\end{center}

%----------------------------------------------------------------------------------------
%	PROBLEM 2
%----------------------------------------------------------------------------------------
\section{Illustrating counting sort}

We illustrate the operation of counting sort on the array
\[A = [4, 6, 3, 5, 0, 5, 1, 3, 5, 5]\]
by showing the values in array $C$ after each step in the three loops internal to counting sort.

\input{q2_table.tex}

%----------------------------------------------------------------------------------------
%	PROBLEM 3
%----------------------------------------------------------------------------------------
\section{Illustrating radix sort}

We illustrate the operation of radix sort on the array
\[A = [392, 517, 364, 931, 726, 912, 299, 250, 600, 185]\]
by showing the values in array $A$ after each intermediate sort.

\input{q3_table.tex}
%----------------------------------------------------------------------------------------
%	PROBLEM 4
%----------------------------------------------------------------------------------------
\section{Illustrating bucket sort}

We illustrate the operation of bucket sort on the array
\[A = [(0.88, 0.23, 0.25, 0.74, 0.18, 0.02, 0.69, 0.56, 0.57, 0.49]\]
by showing the final array B of sorted buckets (before concatenation).\footnote{\LaTeX  TikZ code from \tiny\url{http://tex.stackexchange.com/questions/86766/array-of-linked-lists-like-in-data-structure}}\\
\begin{center}
\input{q4_linked_list.tex}
\end{center}
%----------------------------------------------------------------------------------------
%	PROBLEM 5
%----------------------------------------------------------------------------------------
\FloatBarrier
\section{$d$-ary heaps}

Consider a $d$-ary heap in which all but one node have $d$ children. Our objective is to design a method to store this heap as an array. Note we present the problem in the assigned, but \textbf{the proof of A actually uses the result of part B}. Similarly \textbf{the proof of C actually uses the result of part D}. Additionally, note we derive expressions using 0-indexing. 

\subsection{Parent of the $i$-th node}

By (B), we know the $j$-th child of the $i$-th node in the $d$-ary heap is

\[child_j(i) = d\cdot i + j\]

Now we show the parent of the $i$-th node in the $d$-ary heap is
\[Parent(i) = \left\lfloor \frac{i-1}{d}\right\rfloor\]

Consider the $k^{th}$ node, where $k > 0$. Then there exist unique $i, j \in \mathbb{N}$ such that
\[k = d\cdot i + j\]
where again $1 \leq j \leq d$.

Then, by (B) $k$ must be the $j^{th}$ child of $i$. Now let's find an expression for $i$. Note

\begin{align*}
k &= d\cdot i + j \\
\implies \qquad{} (k -1) &= d \cdot i + (j - 1) \\
\implies \qquad{} \frac{(k -1)}{d} &= i + \frac{(j - 1)}{d}
\end{align*}

But
\[0 \leq \frac{(1 - 1)}{d} \leq \frac{(j - 1)}{d} \leq \frac{(d - 1)}{d} < 1\]

So

\[\left\lfloor \frac{(k-1)}{d} \right\rfloor = \left\lfloor i + \frac{(j-1)}{d} \right\rfloor = i \]

\subsection{$j$-th child of the $i$-th node}

We use induction to prove that the $j$-th child of the $i$-th node in the $d$-ary heap is
\[child_j(i) = d\cdot i + j\]
where $1 \leq j \leq d$.

\textbf{Base case:} Consider $i = 0$. Then the $j^{th}$ child of the $i^{th}$ node is clearly (for $1 \leq j \leq d$)

\[child_j(0) = j = d \cdot 0 + j = d \cdot i + j\]

Now the inductive step:

Assume $child_j(i) = d\cdot i + j$ for all$ i \leq n$. now consider $i = n + 1$.

Then note

\[child_{j = d}(n) = d\cdot n + d\]

by the inductive hypothesis. Thus, the first child of the $(n + 1)^{st}$ node must be

\begin{align*}
child_{j = 0}(n + 1) &= (d\cdot n + d) + 1 \\
	&= d(n+1) + 1
\end{align*}

Then the $j^{th}$ child (for $1 \leq j \leq d$) is
\[child_j(n+1) = d(n+1)+j\]
 
\subsection{Maximum number of nodes at height $h$}

First, note the maximum number of nodes at depth $x$ is clearly $d^x$ (this should be obvious). Next, note that the height of a level in the tree is given by
\begin{align*}
h &= (\max h) - x \\
\implies \qquad{} x &= (\max h) - h
\end{align*}

Then, substituting in the expression for the maximum number of nodes at height $h$ found in part (D) yields

\[x = \left\lfloor \log_d(n(d-1) + 1) - 1 \right\rfloor - h\]

So the maximum number of nodes at height $h$ is
\[\max \textrm{\# nodes} = d^{ \left\lfloor \log_d(n(d-1) + 1) - 1 \right\rfloor - h}\]

\subsection{Maximum height $h$}

First, a quick note to disambiguate notation: in part (C), we let $h$ be a particular height. Here, we will let $h$ be the maximum height of an $n$-element $d$-ary heap.

Now consider an $n$-element $1$-ary heap. The maximum height $h$ is trivially $n - 1$. Going forward, assume $d > 1$. We show the maximum height $h$ is

\[h = \left\lfloor \log_d(n(d-1)+1) - 1 \right\rfloor\]

First, note the maximum number of nodes in a $d$-ary heap of height $h$ is

\[\sum_{i = 0}^h d^i = \max \textrm{number of nodes}\]

Additionally, the minimium number of nodes in a $d$-ary heap of height $h$ is

\[\left(\sum_{i = 0}^{h-1} d^i\right) +1 = \min \textrm{number of nodes}\]

So, given a heap has $n$ nodes the maximum height $h$ is $h$ such that

\[\sum_{i = 0}^{h-1} d^i < n \leq \sum_{i = 0}^h d^i\]

But recall the
\[\sum_{i = 0}^k x^i = \frac{x^{k+1}-1}{x-1}\]

Thus

\begin{align*}
\sum_{i = 0}^{h-1} d^i < n &\leq \sum_{i = 0}^h d^i \\
\implies \qquad{} \frac{d^{h}-1}{d-1} < n &\leq \frac{d^{h+1}-1}{d-1} \\
\implies \qquad{} d^{h}-1 < n(d - 1) &\leq d^{h+1}-1 \\
\implies \qquad{} d^{h} < n(d - 1) +1 &\leq d^{h+1} \\
\implies \qquad{} h < \log_d(n(d - 1) + 1) &\leq h + 1 \\
\implies \qquad{} h - 1 < \log_d(n(d - 1) + 1) - 1 &\leq h \\
\implies \lceil \log_d(n(d - 1) + 1) - 1 \rceil &= h
\end{align*}

So the maximum height of an $n$-element $d$-ary heap is $\lceil \log_d(n(d - 1) + 1) - 1 \rceil$.

%----------------------------------------------------------------------------------------
%	PROBLEM 6
%----------------------------------------------------------------------------------------
 
 \section{Min-priority queue}
 
 In this section we consider a min-priority queue representing a set of integers and supporting the following operations:
 \begin{itemize}
 \item \texttt{insert(k)}: insert an element with value \texttt{k}
 \item \texttt{get-min()}: return the minimum element
 \item \texttt{extract-min()}: remove and return the minimum element
 \end{itemize}
 
 We give pseudocode and worst-case running time for each operation, given the priority queue is implemented with different data structures. Note we assume arrays are dynamic (and support insertions and deletions)

 \subsection{Unordered array}
Let $A = [a_1, \cdots, a_n]$ be an unordered array. Then

\begin{algorithm}\small
\caption{Unordered array operations}
\begin{algorithmic}
\Function{insert}{A, k}
	\State A[n+1] = k
\EndFunction

\Function{get-min}{A}
	\State min = A[1]
	\For {i in 2 to n}
		\If {A[i] < min}
			\State min = A[i]
		\EndIf
	\EndFor
	\State \Return min
\EndFunction

\Function{delete-min}{A}
	\State min = A[1]
	\State min\_index = 1
	\For {i in 2 to n}
		\If {A[i] < min}
			\State min = A[i]
			\State min\_index = i
		\EndIf
	\EndFor
	\State A[min\_index] = A[n]
	\State delete A[n]
	\State \Return min
\EndFunction

\end{algorithmic}
\end{algorithm}

The worst case running times are as follows- note we are assuming space has been pre-allocated for insertion into the array (and as such are ignoring the cost of copying the array into a larger memory block).

\begin{itemize}
\item \texttt{Insert}: Under our previously stated assumption, this operations is O(1).
\item \texttt{Get-min}: This operation is O(n) (since we loop through the entire array once).
\item \texttt{Delete-min}: This operation is O(n). We loop through the entire array once (an O(n) operation), and deleting is constant time (since we are not concerned with array ordering, we can simply replace A[min\_index] with A[n], then delete A[n]).
\end{itemize}

\subsection{Ordered array}

Let $A = [a_1, \cdots, a_n]$ be an ordered array. Since our objective is to implement a min-priority queue, assume it is in reverse order (with the least element at $A[n]$). Then

\begin{algorithm}\small
\caption{Ordered array operations}
\begin{algorithmic}
\Function{insert}{A, k}
	\State Use binary search to find where to insert $k$
	\State Shift all elements in $A[j:n]$ by one index position.
	\State Insert $k$ at array index $j$ (i.e. $A[j] = k$)
\EndFunction
	
\Function{get-min}{A}
	\State \Return A[n]
\EndFunction

\Function{extract-min}{A}
	\State temp = A[n]
	\State delete A[n]
	\State \Return temp
\EndFunction	
\end{algorithmic}
\end{algorithm}

The worst case running times are as follows- again we are assuming space has been pre-allocated for insertion into the array (and as such are ignoring the cost of copying the array into a larger memory block).

\begin{itemize}
\item \texttt{Insert}: Finding where to insert $k$ is O(log n), shifting the elements is O(n), and inserting (after the shift) is O(1). Hence the final running time is
\[\textrm{O(n) + O(log n) + O(1) = O(n)}\]
\item \texttt{Get-min}: This operation is O(1) (since we no longer need to search through the array once it's ordered).
\item \texttt{Delete-min}: This operation is O(1) since again we no longer need to loop through the entire array.
\end{itemize}

\subsection{Unordered linked list}

Now let $A$ be an unordered linked list

\begin{algorithm}\small
\caption{Unordered linked list operations}
\begin{algorithmic}
\Function{insert}{A, k}
	\State new\_node = new Node()
	\State new\_node.value = k
	\State new\_node.next =  A.head.next
	\State A.head.next = new\_node
	\State \Return A
\EndFunction

\Function{get-min}{A}
	\State min = A.head.next.value
	\State node = A.head.next
	\While {node not Null}
		\State node = node.next
		\If {node.value < min}
			\State min = node.value
		\EndIf
	\EndWhile
	\State \Return min
\EndFunction

\Function{extract-min}{A}
	\State points\_to\_min\_node = A.head
	\State last\_seen\_node = A.head
	\State current\_node = A.head.next
	\State min\_node = A.head.next
	\While {current\_node not Null}
		\State last\_seen\_node = current\_node
		\State current\_node = current\_node.next
		\If {current\_node.value < min\_node.value}
			\State min\_node = current\_node
			\State points\_to\_min\_node = last\_seen\_node
		\EndIf
	\EndWhile
	\State points\_to\_min\_node.next = min\_node.next
	\State min = min\_node.value
	\State delete min\_node
	\State \Return min
\EndFunction
\end{algorithmic}
\end{algorithm}

The worst case running times are as follows:

\begin{itemize}
\item \texttt{Insert}: Inserting into an unordered linked list is O(1), all operations are constant time.
\item \texttt{Get-min}: This operation is O(n), since again we need to loop through every node in the linked list.
\item \texttt{Delete-min}: This operation is also O(n), since again we are looping through the entire linked list.
\end{itemize}

\subsection{Ordered linked list}

Now let $A$ be an ordered linked list

\begin{algorithm}\small
\caption{Ordered linked list operations}
\begin{algorithmic}
\Function{insert}{A, k}
	\State last\_seen\_node = A.head
	\State current\_node = A.head.next
	\If {current\_node not Null and current\_node.value < k}
		\State last\_seen\_node = current\_node
		\State current\_node = current\_node.next
	\EndIf 
	\State new\_node = new Node()
	\State new\_node.value = k
	\State new\_node.next = current\_node
	\State last\_seen\_node.next = new\_node	
	\State \Return A
\EndFunction

\Function{get-min}{A}
	\State \Return A.head.next.value
\EndFunction

\Function{extract-min}{A}
	\State min\_node = A.head.next
	\State min = min\_node.value
	\State A.head.next = min\_node.next
	\State delete min\_node
	\State \Return min
\EndFunction

\end{algorithmic}
\end{algorithm}

The worst case running times are as follows:

\begin{itemize}
\item \texttt{Insert}: In the worst case, this operation is O(n), since we may need to search through the entire linked list to find the correct position to insert the node.
\item \texttt{Get-min}: This operation is O(1), since we need only retrieve the first node in the list (as it is sorted).
\item \texttt{Delete-min}: This operation is also O(1), since after getting the first node, all we need to do is redirect pointers (from the head of the list to the second node).
\end{itemize}

\subsection{Min-heap} 

Now let $A$ be a min-heap.

 \begin{algorithm}\small
\caption{Min-heap operations}
\begin{algorithmic}
\Function{insert}{A, k}
	\State A.heap\_size ++
	\State k\_index = n + 1
	\State A[k\_index] = k
	\While {k\_index not 1 and A[k\_index] < A[parent(k\_index)]}
		\State exchange A[k\_index] and A[parent(k\_index)
		\State set k\_index to parent(k\_index)
	\EndWhile
	\State \Return A
\EndFunction

\Function{get-min}{A}
	\State \Return A[1]
\EndFunction

\Function{extract-min}{A}
	\State min = A[1]
	\State A[1] = A[n]
	\State A.heap\_size = A.heap\_size - 1
	\State min-heapify(A, 1)
	\State \Return min
\EndFunction

\end{algorithmic}
\end{algorithm}
 
 
The worst case running times are as follows:

\begin{itemize}
\item \texttt{Insert}: In the worst case, this operation is O(log n), since the while loop may require exchanging elements all the way from the initial index (n+1) at a leaf node, up to the root. The length of this path is O(log n).
\item \texttt{Get-min}: This operation is O(1), since we need only retrieve the root of our min-heap.
\item \texttt{Delete-min}: This operation is also O(log n). After setting A[1] = A[n], min-heapify will run in O(log n) time, since it will make at most O(log n) exchanges (from the root to a leaf of our binary tree).
\end{itemize}

 
%----------------------------------------------------------------------------------------

\end{document}